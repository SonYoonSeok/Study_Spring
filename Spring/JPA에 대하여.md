# JPA에 대하여



## ORM이란 무엇일까?

>  JPA에 대해 알기 전 가장 먼저 알아야 할 개념이라고 볼 수 있다.

### 영속성(Persistence)

* 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성

  * 영속성을 갖지 않는 데이터는 메모리에만 존재하기 때문에 프로그램을 종료시 모두 사라짐

* **영구적인 객체(Object Persistence)**

  * 메모리 상의 데이터를 파일 시스템, RDBMS 등을 활용해 영구 저장하여 영속성을 부여
  * JDBC, Persistence Framework(Hibernate, Mybatis 등)에 저장

* **Persisitence Layer**

  <img src="https://velog.velcdn.com/images%2Fpond1029%2Fpost%2Fc8aa4e20-4dc8-4860-bcff-a3e08d2b0b9f%2Flayerd-architecture.png" align="left" height=50%, width=50%>

  * Software Architecture에서 데이터에 영속성을 부여해주는 계층
  * JDBC를 이용해 직접 구현할 수 있지만 Persistence Framework를 이용한 개발이 더 많이 이루어짐

* **Persistence Framework**

  * JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업으로 DB와 연동되는 시스템을 빠르게 개발하며 안정적인 구동을 보장

### ORM이란

> Object Relational Mapping, 객체-관계 매핑

* 객체와 관계형 데이터베이스의 데이터를 자동으로 **매핑**하여 영속화 
  * 객체 지향 프로그래밍의 **클래스**와 관계형 데이터베이스의 **테이블**, 서로 모델 간에 **패러다임 불일치**가 존재
    -> ***데이터를 중심으로 구조화가 되어있는 데이터베이스에는 객체중심의 상속, 다형성과 같은 개념이 없다. 객체와 데이터가 서로 지향하는 점이 다르기 때문에 패러다임 불일치 문제를 개발자가 해결해야 했다. 때문에 ORM이 등장***
  * ORM을 통해 객체 간 관계를 바탕으로 SQL을 자동생성하여 **패러다임 불일치를 해결**



### ORM의 장단점

* **장점**
  * 객체지향적인 코드로 인해 직관적이고 **비즈니스 로직에 더 집중**할 수 있음
    * SQL Query를 직접 작성하는 것이 아닌 메서드로 데이터를 조작할 수 있어 개발자는 객체 모델로 프로그래밍 하는 데 집중
    * 각 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성이 증가
  * **재사용 및 유지보수**
    * 독립적으로 작성되어 객체들을 재활용 가능
    * 객체지향적인 접근으로 인해 생산성이 증가
  * **DBMS에 대한 종속성 감소**
    * 객체 간 관계를 바탕으로 SQL을 생성하기 때문에 RDBMS의 데이터 구조와 Java의 객체지향 모델 사이의 간격을 좁힐 수 있음
    * 자료형 타입또한 종속적이지 않음
    * 자바에서 사용할 경우 equals(), hashCode()와 같은 기능을 사용할 수 있음
* **단점**
  * 설계를 신중하게 해야 함
  * 프로젝트의 규모와 복잡성이 커질 수록 사용 난이도가 증가
  * 잘못 구현한 경우 속도 저하 및 일관성이 무너짐
  * 대형 쿼리는 성능 향상을 위해 별도의 튜닝을 해야할 경우가 있음
  * DBMS의 고유 기능을 사용하기 어려움



## JPA란

> Java Persistence API로 자바 진영에서 ORM 기술 표준으로 사용되는 **인터페이스** 모음이다.
>
> 실제 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다. 대표적으로 **Hibernate**가 있다.

* `javax.persistance`패키지로 정의된 API
* 객체/관계 메타데이터
* 사용자가 원하는 JPA 구현체를 선택해서 사용 가능
  * Hibernate, EclipseLink 등 ORM Framework

### 영속성 컨텍스트

> 엔티티를 영구 저장하는 환경으로 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 데이터베이스 역할을 한다.

* **Entity Manager**를 통해 엔티티를 저장하거나 조회하면 Entity Manager는 영속성 컨텍스트에 엔티티를 보관하고 관리
  * ex) `em.persist(member)`

### 영속성 컨텍스트의 특징

* **식별자 값**

  * `member1` 형태로 1차 캐시에 저장

* **데이터베이스 저장**

  * JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티들을 데이터베이스에 반영하는데, 이를 `flush`라 부름

* **쓰기 지연**

  * Entity Manager는 트랜잭션을 커밋하기 직전까지 쓰기지연 SQL 저장소에 쿼리를 모아둔다. 후에 트랜잭션을 커밋할 때 모아둔 쿼리를 한번에 DB에 전송

* **변경 감지**

  * 영속성 컨텍스트가 관리하는 **영속 상태**의 엔티티는 변경 감지를 제공한다.

    변경감지의 흐름

    1. 트랜잭션 커밋 시 엔티티 매니저 내부에서 **플러시**를호출
    2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾음
    3. 변경된 엔티티가 있다면 수정 쿼리를 생성해 쓰기지연 SQL저장소에 저장
    4. 저장소의 SQL을 **플러시**
    5. 트랜잭션을 커밋

### 플러시

> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 엔티티를 지우는 것이 아니라 변경 내용을 데이터베이스에 동기화 하는 것이다.

* 트랜잭션 커밋시 자동 호출
* JPQL 쿼리 실행시 자동 호출
* `em.flush()`를 사용해 호출

### 엔티티의 생명주기

<img src="https://velog.velcdn.com/images%2Fneptunes032%2Fpost%2Fecd3b113-862f-4158-a208-e1eeec92d61d%2Fimage.png" align="left">

**비영속**

엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않는 상태 (new/transient)
```java
Member member = new Member();
```



**영속**

Entity Manager를 통해 엔티티를 영속성 컨텍스트에 저장한 상태를 말하며 영속성 컨텍스트에 의해 관리중인 상태

```java
em.persist(member);
```



**준영속**

영속성 컨텍스트가 영속 상태의 엔티티를 더이상 관리하지 않는 상태

```java
em.detach(member); // 엔티티를 분리해 준영속 상태로 만든다.

em.clear(); // 영속성 컨텍스트를 비워도 준영속 상태

em.close(); // 영속성 컨텍스트를 종료해도 준영속 상태
```

* 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떤 기능도 동작 X

* 식별자 값을 가짐

  

**삭제**

엔티티를 영속성 컨텍스트와 DB에서 삭제

```java
em.remove(member);
```



<hr/>